{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This Primer aims to help you understand foundations of geospatial analysis and visualization with Google Earth Engine. It is intended for people who are unfamiliar with geospatial or Earth Engine concepts and methods. This is a work in progress. I hope to have the first draft complete by January 2022. For questions or comments, please contact: Jeff Howarth Associate Professor Geography Department Middlebury College, Vermont, USA email: jhowarth@middlebury.edu twitter: @jeffgeographer","title":"Preface"},{"location":"00/mapFoundations/","text":"Introduction Please note: this is a rough, incomplete draft. I may develop an app for this rather than having students use the code editor. The shape of the Earth can be idealized as an ellipsoid, or something that resembles a ball that is just a little bit wider than tall. To display a map of the Earth on a computer screen, we must use a system that can 'map' locations from this three-dimensional shape to the two-dimensional surface of a computer monitor. Inevitably, this stretches space in some parts of the map and distorts some spatial properties, like distance and area. In this chapter, we will explore how the Map User Interface (UI) in Earth Engine's Code Editor uses a geographic coordinate system, a map projection, and scale to display geographic information on flat displays. We will also visualize the spatial distortions that this cartographic system creates. By the end of the chapter, you should understand how to: change the scale, extent, and basemap of the Map UI create point, line, and polygon geometries explain why the Map UI distorts distance, area, and shape of geometries Map User Interface Base layer When you start the Code Editor, the Map UI displays Google's familiar road map as the base layer . It will always be drawn first. If we add other layers to the map, the base layer will always appear on the bottom of the stack. Google's road map was designed to help people navigate transportation networks. Like any good map design, it does not clutter the map display with information that does not directly support the map's purpose. So it does not provide many details about land cover, settlement patterns, geomorphology, or other attributes of the Earth's surface that you might actually want to investigate with Earth Engine. Consequently, you may find it helpful to change the base layer to a satellite image or a shaded relief map. Use the buttons in the upper right corner of the map window to manually select a different base layer. After you have changed the layer, click run on the Code Editor to rerun your script. Note that you can change the base layer manually, but it will revert to Google's road map whenever you re-run your code. To avoid this, you can define the base layer to display on the map as part of your script. Copy and paste the snippet below into the Editor and then click Run . Map . setOptions ( 'HYBRID' ); Zoom level Zoom level defines map scale . The snippet below will print the zoom level to the Console panel whenever you run your script. print ( Map . getZoom ()); The default zoom level (4) shows a small scale map. When you increase the zoom level, you increase the map scale, which creates the illusion of bringing the map closer to you. Click on the + button in the upper left corner of map window until you can not zoom in any further. Then Run the script. You should see the number 20 in the Console window. This is the largest zoom level provided by the Map UI. Now click on the - button until you can not zoom any futher out. Then Run the script. You should see the number 0 in the Console panel. This is the smallest scale that you can view. Notice the peculiar asymmetry of the map display: it has northern and southern limits, but appears to be continuous in the eastern and western directions. As a result, the map shows places more than once. This may look strange, but as we will discuss in a minute, it helps solve an inherent problem of displaying a round object on a flat surface. Map center The map center is a point defined by a geographic coordinate . The snippet below will print the point's coordinates to the Console panel whenever you run your script. print ( Map . getCenter ()); If you are used to thinking about latitude and longitude in that order, then you should note that the order shown here is opposite of this, because it follows the \"x,y\" convention of coordinates. As a geographic coordinate, longitude is plotted along the x-axis and latitude on the y-axis, which is counter-intuitive for many people, because we tend to equate longitude with vertical lines and latitude with horizontal lines. The map's default center (-95.20, 34.80) is a point on Choctaw Nation land in southeastern Oklahoma in the USA. The longitude is a negative number, because the point lies west of the prime meridian (in Greenwich, England). The latitude is positive because the point lies north of the equator . This follows a conventional geographic coordinate system for world maps that can represent any location on Earth with a longitude between -180 and 180 and a latitude between 90 and -90. insert image Map display coordinates As noted earlier, the map displayed on your monitor does not have an eastern or western limit. In other words, it does not abruptly end at 180 degrees east and west of Greenwich. Use the pan button in the upper left of the map window to move the map center towards the east a few times (this will involve clicking and dragging towards the left). Then re-run the script. You should find that you can drag the map so that the longitude of the center point is quite a bit greater than 180 degrees. This is what generates the repeating geography we noted earlier. It may look odd, but it allows the map to display the region of Earth that spans the 180 th meridian without splitting it up on either side of the display. Often, flat world maps that are printed on paper must cut up this geography, which is why it is common to see a little piece of Russia hanging on a world map's western edge and a string of Aleutian islands creeping in from the east. Like many web maps, the Code Editor map solves this problem by extending the display's coordinate system past 180 longitude. This continuous lateral scroll also allows the map user to explore the world by panning in only one direction, similar to how a globe allows the map user to spin it one direction for any number of revolutions. On modern monitors, the lowest zoom level may appear excessive, showing the same place seven or more times. But the amount of Earth that is visible in the map window depends not only on zoom level, but also on the number of pixels that a screen can display. For example, an iPhone 5 displays only 320 x 568 pixels. At zoom level 0, this screen resolution will display a map that depicts every location on Earth twice, which means you can show any region on Earth continuously on the screen. Map extent Together, map center and zoom level define the map extent , or the region of the world displayed on the map. As you have seen, you can change these both manually with the zoom and pan buttons, Map . setCenter ( 125 , 35 , 6 ); TO BE CONTINUED...","title":"Intro to web maps"},{"location":"00/mapFoundations/#introduction","text":"Please note: this is a rough, incomplete draft. I may develop an app for this rather than having students use the code editor. The shape of the Earth can be idealized as an ellipsoid, or something that resembles a ball that is just a little bit wider than tall. To display a map of the Earth on a computer screen, we must use a system that can 'map' locations from this three-dimensional shape to the two-dimensional surface of a computer monitor. Inevitably, this stretches space in some parts of the map and distorts some spatial properties, like distance and area. In this chapter, we will explore how the Map User Interface (UI) in Earth Engine's Code Editor uses a geographic coordinate system, a map projection, and scale to display geographic information on flat displays. We will also visualize the spatial distortions that this cartographic system creates. By the end of the chapter, you should understand how to: change the scale, extent, and basemap of the Map UI create point, line, and polygon geometries explain why the Map UI distorts distance, area, and shape of geometries","title":"Introduction"},{"location":"00/mapFoundations/#map-user-interface","text":"","title":"Map User Interface"},{"location":"00/mapFoundations/#base-layer","text":"When you start the Code Editor, the Map UI displays Google's familiar road map as the base layer . It will always be drawn first. If we add other layers to the map, the base layer will always appear on the bottom of the stack. Google's road map was designed to help people navigate transportation networks. Like any good map design, it does not clutter the map display with information that does not directly support the map's purpose. So it does not provide many details about land cover, settlement patterns, geomorphology, or other attributes of the Earth's surface that you might actually want to investigate with Earth Engine. Consequently, you may find it helpful to change the base layer to a satellite image or a shaded relief map. Use the buttons in the upper right corner of the map window to manually select a different base layer. After you have changed the layer, click run on the Code Editor to rerun your script. Note that you can change the base layer manually, but it will revert to Google's road map whenever you re-run your code. To avoid this, you can define the base layer to display on the map as part of your script. Copy and paste the snippet below into the Editor and then click Run . Map . setOptions ( 'HYBRID' );","title":"Base layer"},{"location":"00/mapFoundations/#zoom-level","text":"Zoom level defines map scale . The snippet below will print the zoom level to the Console panel whenever you run your script. print ( Map . getZoom ()); The default zoom level (4) shows a small scale map. When you increase the zoom level, you increase the map scale, which creates the illusion of bringing the map closer to you. Click on the + button in the upper left corner of map window until you can not zoom in any further. Then Run the script. You should see the number 20 in the Console window. This is the largest zoom level provided by the Map UI. Now click on the - button until you can not zoom any futher out. Then Run the script. You should see the number 0 in the Console panel. This is the smallest scale that you can view. Notice the peculiar asymmetry of the map display: it has northern and southern limits, but appears to be continuous in the eastern and western directions. As a result, the map shows places more than once. This may look strange, but as we will discuss in a minute, it helps solve an inherent problem of displaying a round object on a flat surface.","title":"Zoom level"},{"location":"00/mapFoundations/#map-center","text":"The map center is a point defined by a geographic coordinate . The snippet below will print the point's coordinates to the Console panel whenever you run your script. print ( Map . getCenter ()); If you are used to thinking about latitude and longitude in that order, then you should note that the order shown here is opposite of this, because it follows the \"x,y\" convention of coordinates. As a geographic coordinate, longitude is plotted along the x-axis and latitude on the y-axis, which is counter-intuitive for many people, because we tend to equate longitude with vertical lines and latitude with horizontal lines. The map's default center (-95.20, 34.80) is a point on Choctaw Nation land in southeastern Oklahoma in the USA. The longitude is a negative number, because the point lies west of the prime meridian (in Greenwich, England). The latitude is positive because the point lies north of the equator . This follows a conventional geographic coordinate system for world maps that can represent any location on Earth with a longitude between -180 and 180 and a latitude between 90 and -90. insert image","title":"Map center"},{"location":"00/mapFoundations/#map-display-coordinates","text":"As noted earlier, the map displayed on your monitor does not have an eastern or western limit. In other words, it does not abruptly end at 180 degrees east and west of Greenwich. Use the pan button in the upper left of the map window to move the map center towards the east a few times (this will involve clicking and dragging towards the left). Then re-run the script. You should find that you can drag the map so that the longitude of the center point is quite a bit greater than 180 degrees. This is what generates the repeating geography we noted earlier. It may look odd, but it allows the map to display the region of Earth that spans the 180 th meridian without splitting it up on either side of the display. Often, flat world maps that are printed on paper must cut up this geography, which is why it is common to see a little piece of Russia hanging on a world map's western edge and a string of Aleutian islands creeping in from the east. Like many web maps, the Code Editor map solves this problem by extending the display's coordinate system past 180 longitude. This continuous lateral scroll also allows the map user to explore the world by panning in only one direction, similar to how a globe allows the map user to spin it one direction for any number of revolutions. On modern monitors, the lowest zoom level may appear excessive, showing the same place seven or more times. But the amount of Earth that is visible in the map window depends not only on zoom level, but also on the number of pixels that a screen can display. For example, an iPhone 5 displays only 320 x 568 pixels. At zoom level 0, this screen resolution will display a map that depicts every location on Earth twice, which means you can show any region on Earth continuously on the screen.","title":"Map display coordinates"},{"location":"00/mapFoundations/#map-extent","text":"Together, map center and zoom level define the map extent , or the region of the world displayed on the map. As you have seen, you can change these both manually with the zoom and pan buttons, Map . setCenter ( 125 , 35 , 6 ); TO BE CONTINUED...","title":"Map extent"},{"location":"01/01cuts/","text":"4. Inspect image collection Now let's inspect the set of values stored in an image collection at a location. Please do the following: In the right-hand panel, click on the Inspector tab. Your cursor should now appear like a crosshair. On the map, click a location on the map. You should see Point , Pixels , and Object information appear in the Inspector panel. In the Inspector panel, click the carrot (the little arrowhead) next to Pixels . This should expand the information. Then click the carrots to expand information for Lights at night and then Series . You should now see a chart. The chart reports the raster value at the location you clicked for every image and band in the image collection. If you want to make the chart bigger, you can click the icon in the upper right corner of the chart panel. This should open the chart in a new browser tab. Please note that if you hover the cursor above any point on a line in the chart, you will retrieve the data value and time-stamp for that point. Please try to answer these questions: What does each colored line in the chart represent? What does the y-axis represent? What does the x-axis represent? What is the temporal resolution of each image in the collection (what length of time does each image represent)? What is the temporal extent of the image collection (what is the first and last dates in the image collection)? Why do you think that the plotted lines occasionally form steep vertical segments perpendicular to the x-axis? 5. Image collection as a layer Now that we have inspected the image collection, we can see that it consists of a set of images over time, where each image is composed of four different bands. We should pause here for a moment and ask: which image and which band are we then displaying on the map? We told Earth Engine which band to display in our visualization scheme (we defined it with the band key). But we never told Earth Engine which image we should display from the collection. It made this decision for us. You should be able to figure out which image Earth Engine displays from an Image Collection by looking at the information in the Inspector panel. Expand the carrot next to Mosaic and look at the data values for each band. Then expand the carrot next to Series and hover your cursor over points in each plotted line. What image from the collection does the map display as a layer? How would you describe the position of this image in the stack of images of the collection? 6. Reduce image collection Now let's look at how you can ask Earth Engine to display a different layer from the stack. Add the code below to your script and run the script. // Add first image in collection as map layer Map . addLayer ( lights . first (), // Draw first image in the 'lights' collection lightsViz , // Name of object with viz parameters 'Lights at night: first image' , // Name for layer as a string 1 , // Visibility of layer 1 ); // Opacity of layer This should add a second layer to your map. Notice that in the arguments for .addLayer , we modified the image collection with the .first() method. This tells Earth Engine to reduce the image collection to the first image in the collection. Use the Inspector to explore this a little further. With the crosshair cursor, click on a location on the map and look at the information in the Inspector panel and then look at the information under Pixels . How do Lights at night and Lights at night: first image differ as raster datasets? Why does Lights at night have a Series option but Lights at night: first image does not? Under Series for Lights at night , what point in the chart matches the data values for the Lights at night: first image ? Filter by time and band Now let's get back to writing more code. At this point, you may sense that our image collection suffers from a bit of excess. We constructed \"lights\" from the entire dataset in the EE catalog. As a result, it is a tall stack of rasters, containing every but for our analysis, we will only need a subset of the dataset. So our next task is to shorten the stack of rasters. To do this, we can filter the image collection in two ways: by time by band name This snippet filters by time and prints the result to the console: var lights03 = lights . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )); print ( 'Lights 2003' , lights03 ); This calls an image collection's filter method and then uses the filter's calendarRange method, where the parameters define the range's start, end, and calendar field. In this example, we use the 'year' calendar field because each image in the nighttime lights collection represents an average for the calendar year so there is no reason to define a filter smaller than this. The second line prints a label and metadata to the Console. Inspect the metadata and note that now your image collection contains two images and both are for the year 2003. This snippet filters by band name and prints the result to the console: var lights03Select = lights03 . select ( 'stable_lights' ); print ( 'Nighttime lights 2003 Select' , lights03Select ); It calls an image collection's select method, where the parameter states the band name. Inspect the metadata and note that this image collection only contains one band. This code did the job, but it could be more concise. We could replicate all the code that we have written thus far with the following: var lights03_stable_first = ee . ImageCollection ( \"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\" ) . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )) . select ( 'stable_lights' ); print ( 'Lights 2003: concise method' , lights03_stable_first ); If you inspect the metadata, you should see this image collection is identical to the collection we made earlier. To help understand why, let's review how raster workflows work.","title":"01cuts"},{"location":"01/01cuts/#4-inspect-image-collection","text":"Now let's inspect the set of values stored in an image collection at a location. Please do the following: In the right-hand panel, click on the Inspector tab. Your cursor should now appear like a crosshair. On the map, click a location on the map. You should see Point , Pixels , and Object information appear in the Inspector panel. In the Inspector panel, click the carrot (the little arrowhead) next to Pixels . This should expand the information. Then click the carrots to expand information for Lights at night and then Series . You should now see a chart. The chart reports the raster value at the location you clicked for every image and band in the image collection. If you want to make the chart bigger, you can click the icon in the upper right corner of the chart panel. This should open the chart in a new browser tab. Please note that if you hover the cursor above any point on a line in the chart, you will retrieve the data value and time-stamp for that point. Please try to answer these questions: What does each colored line in the chart represent? What does the y-axis represent? What does the x-axis represent? What is the temporal resolution of each image in the collection (what length of time does each image represent)? What is the temporal extent of the image collection (what is the first and last dates in the image collection)? Why do you think that the plotted lines occasionally form steep vertical segments perpendicular to the x-axis?","title":"4. Inspect image collection"},{"location":"01/01cuts/#5-image-collection-as-a-layer","text":"Now that we have inspected the image collection, we can see that it consists of a set of images over time, where each image is composed of four different bands. We should pause here for a moment and ask: which image and which band are we then displaying on the map? We told Earth Engine which band to display in our visualization scheme (we defined it with the band key). But we never told Earth Engine which image we should display from the collection. It made this decision for us. You should be able to figure out which image Earth Engine displays from an Image Collection by looking at the information in the Inspector panel. Expand the carrot next to Mosaic and look at the data values for each band. Then expand the carrot next to Series and hover your cursor over points in each plotted line. What image from the collection does the map display as a layer? How would you describe the position of this image in the stack of images of the collection?","title":"5. Image collection as a layer"},{"location":"01/01cuts/#6-reduce-image-collection","text":"Now let's look at how you can ask Earth Engine to display a different layer from the stack. Add the code below to your script and run the script. // Add first image in collection as map layer Map . addLayer ( lights . first (), // Draw first image in the 'lights' collection lightsViz , // Name of object with viz parameters 'Lights at night: first image' , // Name for layer as a string 1 , // Visibility of layer 1 ); // Opacity of layer This should add a second layer to your map. Notice that in the arguments for .addLayer , we modified the image collection with the .first() method. This tells Earth Engine to reduce the image collection to the first image in the collection. Use the Inspector to explore this a little further. With the crosshair cursor, click on a location on the map and look at the information in the Inspector panel and then look at the information under Pixels . How do Lights at night and Lights at night: first image differ as raster datasets? Why does Lights at night have a Series option but Lights at night: first image does not? Under Series for Lights at night , what point in the chart matches the data values for the Lights at night: first image ?","title":"6. Reduce image collection"},{"location":"01/01cuts/#filter-by-time-and-band","text":"Now let's get back to writing more code. At this point, you may sense that our image collection suffers from a bit of excess. We constructed \"lights\" from the entire dataset in the EE catalog. As a result, it is a tall stack of rasters, containing every but for our analysis, we will only need a subset of the dataset. So our next task is to shorten the stack of rasters. To do this, we can filter the image collection in two ways: by time by band name This snippet filters by time and prints the result to the console: var lights03 = lights . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )); print ( 'Lights 2003' , lights03 ); This calls an image collection's filter method and then uses the filter's calendarRange method, where the parameters define the range's start, end, and calendar field. In this example, we use the 'year' calendar field because each image in the nighttime lights collection represents an average for the calendar year so there is no reason to define a filter smaller than this. The second line prints a label and metadata to the Console. Inspect the metadata and note that now your image collection contains two images and both are for the year 2003. This snippet filters by band name and prints the result to the console: var lights03Select = lights03 . select ( 'stable_lights' ); print ( 'Nighttime lights 2003 Select' , lights03Select ); It calls an image collection's select method, where the parameter states the band name. Inspect the metadata and note that this image collection only contains one band. This code did the job, but it could be more concise. We could replicate all the code that we have written thus far with the following: var lights03_stable_first = ee . ImageCollection ( \"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\" ) . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )) . select ( 'stable_lights' ); print ( 'Lights 2003: concise method' , lights03_stable_first ); If you inspect the metadata, you should see this image collection is identical to the collection we made earlier. To help understand why, let's review how raster workflows work.","title":"Filter by time and band"},{"location":"01/rasterFoundations/","text":"Introduction This chapter introduces core concepts for representing geographic information with a raster data model. We will use Google Earth Engine to work with a dataset of nighttime lights and make the map layer shown below. By the end, you should be able to answer these questions: How does a raster data model represent attributes of spatial locations ? What is a raster's spatial resolution and extent ? What is a raster's temporal resolution and extent ? How can a raster represent multiple attributes for spatial locations at multiple times ? What is a data type versus a data value ? What is a display palette ? What is stretch enhancement and why does it help display data values with colors? Practically, you will learn how to use the Earth Engine Code Editor to: construct an image collection from an address in the Earth Engine data catalog visualize an image band with a color scheme Import dataset In this chapter, we will work with a global dataset of nighttime lights. Our first task is to create a copy of the dataset and give it a name. You will need to open the Code Editor if you have not already done so. Then copy or type the following code into the Code Editor and run the script. var lights = ee . ImageCollection ( \"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\" ); // import image collection print ( \"Lights at night dataset\" , lights ); // inspect results The first line gives us a copy of the dataset to work with. Technically, it uses Earth Engine's ImageCollection method to create an instance of the dataset (as a variable ) and assigns the instance a name of our choosing (we called it 'lights'). The method's argument (in parenthesis) calls the asset ID (like a pathname) in the Earth Engine Data Catalog. The second line prints two things to the Console panel : a label and the collection's metadata (data about data). Go ahead and inspect the information that you printed to the Console panel. Take note of the key vocabulary terms in bold below: The image collection consists of a set of images (listed as features of the image collection). The image collection and each image has a set of properties (some of which are human readable and some of which seem intended for a computer). Each image consists of a set of bands (the names of which are a little cryptic, but you can follow the provider_url in the image collection properties to find descriptions of them). Each band has a name, a crs (coordinate reference system), a data_type , and dimensions . If this architecture and vocabulary are new to you, the next section reviews how the raster data model works as a general template for storing spatial information. Raster data model The raster data model represents spatial information as a grid of values. The position of a value in the grid represents location. Each value represents an attribute of the location. The illustration above shows two versions of a raster for a small portion of the nighttime lights dataset. The left-side shows how the computer encodes the data and the right-side shows a scheme that is a bit more readable. On the left, the array holds 8 bit unsigned integers. This data type uses eight binary numbers to represent integer data values between 0 and 255. The scheme on the right shows a grid with four columns and five rows. Each cell in the grid is called a pixel (short for \"picture element\"). The number of pixels in each row and column define the dimensions of the raster. As you can see, the raster data model stores one value for each location. Given this simple fact, we should ask: how can we use a raster data model to store more than one attribute for each location? For example, the nighttime lights dataset describe brightness of lights at every location in a raster for more than one year. Furthermore, this dataset also describes a few different categories of brightness for every location in the raster. How does it do this? The solution is two-part: use more than one raster and use a hierarchy to organize them. This is where bands and image collections come in. The figure below illustrates EE's raster system that we glimpsed when we inspected the nighttime lights information that we printed to the Console panel. The image collection consists of a set of images. Each image in the image collection represents a different time observation . Each band in an image represents a different category of attributes . insert figure for image collection architecture... Visualize data with color Our next task is to visualize the data as a map layer. This will involve a few steps: Define a color palette for visualizing raster values. Define a visualization scheme (how raster values relate to the color palette). Apply visualization scheme to a raster as a map layer. The code below defines a color palette . // Create a color palette var lightsPalette = [ 'black' , '#000b4a' , '#5a2c49' , '#94574e' , '#c9875e' , '#f4bf87' , 'white' ]; // Inspect palette in Console print ( 'Color palette' , lightsPalette ); The palette is a list of HTML colors, and each HTML color is a string . (Lists are enclosed in brackets and strings are enclosed in quotation marks.) Our example illustrates two different ways that you can specify colors. First, you can use HTML color names , like 'Black' and 'White'. There are 140 different HTML color names that will be recognized by all modern browsers and are safe to use in Earth Engine. Alternatively, you can also define colors with hexadecimal codes , which consist of six characters following a pound sign. These allow you to create custom colors as additive combinations of red, green, and blue. The code below defines a visualization scheme . // Create viz scheme var lightsViz = { // Name of Viz object min : 0 , // Value to display with first color in palette max : 63 , // Value to display with last color in palette bands : 'stable_lights' , // Name of the band with data values palette : lightsPalette // Refers to the palette defined previously }; // Inspect viz scheme in Console print ( 'Viz scheme' , lightsViz ); The visualization scheme is an object (enclosed in curly brackets). The min and max keys define the data range that we want to display with colors, while the palette key references the list of colors we made previously. In this example, we are defining the data range based on the minimum and maximum values that populate the raster. Often, these will be documented as properties of the image collection, but not necessarily for all bands. Alternatively, you can also look in EE's Data Catalog for metadata about the collection. It is often listed under the Bands tab . Stretch enhancement Visualization parameters help resolve a common mismatch between the range of values that a raster can store (defined by the raster's data type ) and the range of values that populate the raster. Often, the range of values that populate a raster is much smaller than the range of values that the data type can represent. This affects our ability to see differences in our data when we visualize raster values with color. Stretch enhancement is a method to tune the range of display colors to the range of populated data values in order to improve visual contrast. The frequency distribution above illustrates this for our simple 20 pixel example introduced previously. It shows the number of pixels (y-axis) that populate the raster for each value provided by the data type (x-axis). The eight bit unsigned integer data type can represent all integers between 0 and 255, but our raster contains values over a much smaller range (0 - 48). Now consider that the pixel depth will also control the number of colors available to visualize the raster values. In the illustration, the palette lists seven discrete colors. These colors seed a color ramp that then represents all the potential values provided by the pixel depth. The first color represents 0, the last color represents 255. The other colors are distributed evenly across the middle and transitional colors fill in the gaps. The color ramp appears continuous, but it really just represents 256 steps between black and white that pass through the other five colors at equal intervals. The raw display simply uses the color ramp to represent all the potential values in the raster as defined by the data type. The result has poor contrast, because we are only using a small part of our color ramp to display our raster values. The stretched display solves this by stretching our data range (defined by the minimum and maximum values, or 0 and 48 in this toy example) over the entire color ramp. This improves contrast dramatically, because we are now using our full range of color to represent our full range of populated values. Add map layer We apply the visualization scheme when we represent raster values as a layer on the map. For example: // Add map layer Map . addLayer ( lights , // Name of dataset with values to display as a layer lightsViz , // Name of object with viz parameters 'Lights at night' , // Name for layer as a string 1 , // Visibility of layer 1 ); // Opacity of layer This uses the Map's addLayer method and takes five arguments (each described with comments). When you run the code, the Map UI will apply the 'lightsViz' visualization scheme to the 'lights' image collection. Try clicking the layers button on the top right of the map window. You should see the layer name ('Lights at night') and a check mark signifying that the layer is being shown. We made the layer opaque, so we can not see the base map underneath it, but you can use the slider to the right of the label to reduce the opacity (making the layer appear more transparent). Practice problems Let's review some of the concepts we have touched on thus far. In this section, we will make small changes to the code we have written in an effort to better understand how raster methods work. 1. Color palette Please alter the visualization scheme by making the palette key and value pair a comment, as shown below. This will tell Earth Engine to ignore this line when you run the script. var lightsViz = { // Name of Viz object min : 0 , // Value to display with first color in palette max : 63 , // Value to display with last color in palette bands : 'stable_lights' , // Name of the band with data values // palette: lightsPalette // Refers to the palette defined previously }; After you have made this change, go ahead and run the script. What looks different about the map layer? How would you describe the palette that Earth Engine uses by default if you do not define one in the visualization scheme? 2. Stretch enhancement Please alter the visualization scheme so that the min and max key and value pairs are commented, as shown below. After you have made these changes, please run the script. var lightsViz = { // Name of Viz object // min:0, // Value to display with first color in palette // max: 63, // Value to display with last color in palette bands : 'stable_lights' , // Name of the band with data values palette : lightsPalette // Refers to the palette defined previously }; How did this change the contrast of your map layer? How does this affect your ability to interpret your data? Before moving on, please be sure to undo the changes that you made to the visualization scheme to restore the original palette and stretch enhancement. 3. Layer arguments Let's explore the arguments of the addLayer method. Please try to alter the arguments as described below. For each, please describe how the change affects the display of the map layer. Change the layer name to 'This is the layer name' and run the script. Change the layer visibility to 0 and run the script. Change visibility to true and run the script. Change visibility to false and run the script. Change opacity to 0 and run the script. Change opacity to true and run the script. Finally, why do you think the visibility and opacity parameters behave differently? Before moving on, please be sure to return the script to the original form described in the Add map layer section above.","title":"Raster data model"},{"location":"01/rasterFoundations/#introduction","text":"This chapter introduces core concepts for representing geographic information with a raster data model. We will use Google Earth Engine to work with a dataset of nighttime lights and make the map layer shown below. By the end, you should be able to answer these questions: How does a raster data model represent attributes of spatial locations ? What is a raster's spatial resolution and extent ? What is a raster's temporal resolution and extent ? How can a raster represent multiple attributes for spatial locations at multiple times ? What is a data type versus a data value ? What is a display palette ? What is stretch enhancement and why does it help display data values with colors? Practically, you will learn how to use the Earth Engine Code Editor to: construct an image collection from an address in the Earth Engine data catalog visualize an image band with a color scheme","title":"Introduction"},{"location":"01/rasterFoundations/#import-dataset","text":"In this chapter, we will work with a global dataset of nighttime lights. Our first task is to create a copy of the dataset and give it a name. You will need to open the Code Editor if you have not already done so. Then copy or type the following code into the Code Editor and run the script. var lights = ee . ImageCollection ( \"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\" ); // import image collection print ( \"Lights at night dataset\" , lights ); // inspect results The first line gives us a copy of the dataset to work with. Technically, it uses Earth Engine's ImageCollection method to create an instance of the dataset (as a variable ) and assigns the instance a name of our choosing (we called it 'lights'). The method's argument (in parenthesis) calls the asset ID (like a pathname) in the Earth Engine Data Catalog. The second line prints two things to the Console panel : a label and the collection's metadata (data about data). Go ahead and inspect the information that you printed to the Console panel. Take note of the key vocabulary terms in bold below: The image collection consists of a set of images (listed as features of the image collection). The image collection and each image has a set of properties (some of which are human readable and some of which seem intended for a computer). Each image consists of a set of bands (the names of which are a little cryptic, but you can follow the provider_url in the image collection properties to find descriptions of them). Each band has a name, a crs (coordinate reference system), a data_type , and dimensions . If this architecture and vocabulary are new to you, the next section reviews how the raster data model works as a general template for storing spatial information.","title":"Import dataset"},{"location":"01/rasterFoundations/#raster-data-model","text":"The raster data model represents spatial information as a grid of values. The position of a value in the grid represents location. Each value represents an attribute of the location. The illustration above shows two versions of a raster for a small portion of the nighttime lights dataset. The left-side shows how the computer encodes the data and the right-side shows a scheme that is a bit more readable. On the left, the array holds 8 bit unsigned integers. This data type uses eight binary numbers to represent integer data values between 0 and 255. The scheme on the right shows a grid with four columns and five rows. Each cell in the grid is called a pixel (short for \"picture element\"). The number of pixels in each row and column define the dimensions of the raster. As you can see, the raster data model stores one value for each location. Given this simple fact, we should ask: how can we use a raster data model to store more than one attribute for each location? For example, the nighttime lights dataset describe brightness of lights at every location in a raster for more than one year. Furthermore, this dataset also describes a few different categories of brightness for every location in the raster. How does it do this? The solution is two-part: use more than one raster and use a hierarchy to organize them. This is where bands and image collections come in. The figure below illustrates EE's raster system that we glimpsed when we inspected the nighttime lights information that we printed to the Console panel. The image collection consists of a set of images. Each image in the image collection represents a different time observation . Each band in an image represents a different category of attributes . insert figure for image collection architecture...","title":"Raster data model"},{"location":"01/rasterFoundations/#visualize-data-with-color","text":"Our next task is to visualize the data as a map layer. This will involve a few steps: Define a color palette for visualizing raster values. Define a visualization scheme (how raster values relate to the color palette). Apply visualization scheme to a raster as a map layer. The code below defines a color palette . // Create a color palette var lightsPalette = [ 'black' , '#000b4a' , '#5a2c49' , '#94574e' , '#c9875e' , '#f4bf87' , 'white' ]; // Inspect palette in Console print ( 'Color palette' , lightsPalette ); The palette is a list of HTML colors, and each HTML color is a string . (Lists are enclosed in brackets and strings are enclosed in quotation marks.) Our example illustrates two different ways that you can specify colors. First, you can use HTML color names , like 'Black' and 'White'. There are 140 different HTML color names that will be recognized by all modern browsers and are safe to use in Earth Engine. Alternatively, you can also define colors with hexadecimal codes , which consist of six characters following a pound sign. These allow you to create custom colors as additive combinations of red, green, and blue. The code below defines a visualization scheme . // Create viz scheme var lightsViz = { // Name of Viz object min : 0 , // Value to display with first color in palette max : 63 , // Value to display with last color in palette bands : 'stable_lights' , // Name of the band with data values palette : lightsPalette // Refers to the palette defined previously }; // Inspect viz scheme in Console print ( 'Viz scheme' , lightsViz ); The visualization scheme is an object (enclosed in curly brackets). The min and max keys define the data range that we want to display with colors, while the palette key references the list of colors we made previously. In this example, we are defining the data range based on the minimum and maximum values that populate the raster. Often, these will be documented as properties of the image collection, but not necessarily for all bands. Alternatively, you can also look in EE's Data Catalog for metadata about the collection. It is often listed under the Bands tab .","title":"Visualize data with color"},{"location":"01/rasterFoundations/#stretch-enhancement","text":"Visualization parameters help resolve a common mismatch between the range of values that a raster can store (defined by the raster's data type ) and the range of values that populate the raster. Often, the range of values that populate a raster is much smaller than the range of values that the data type can represent. This affects our ability to see differences in our data when we visualize raster values with color. Stretch enhancement is a method to tune the range of display colors to the range of populated data values in order to improve visual contrast. The frequency distribution above illustrates this for our simple 20 pixel example introduced previously. It shows the number of pixels (y-axis) that populate the raster for each value provided by the data type (x-axis). The eight bit unsigned integer data type can represent all integers between 0 and 255, but our raster contains values over a much smaller range (0 - 48). Now consider that the pixel depth will also control the number of colors available to visualize the raster values. In the illustration, the palette lists seven discrete colors. These colors seed a color ramp that then represents all the potential values provided by the pixel depth. The first color represents 0, the last color represents 255. The other colors are distributed evenly across the middle and transitional colors fill in the gaps. The color ramp appears continuous, but it really just represents 256 steps between black and white that pass through the other five colors at equal intervals. The raw display simply uses the color ramp to represent all the potential values in the raster as defined by the data type. The result has poor contrast, because we are only using a small part of our color ramp to display our raster values. The stretched display solves this by stretching our data range (defined by the minimum and maximum values, or 0 and 48 in this toy example) over the entire color ramp. This improves contrast dramatically, because we are now using our full range of color to represent our full range of populated values.","title":"Stretch enhancement"},{"location":"01/rasterFoundations/#add-map-layer","text":"We apply the visualization scheme when we represent raster values as a layer on the map. For example: // Add map layer Map . addLayer ( lights , // Name of dataset with values to display as a layer lightsViz , // Name of object with viz parameters 'Lights at night' , // Name for layer as a string 1 , // Visibility of layer 1 ); // Opacity of layer This uses the Map's addLayer method and takes five arguments (each described with comments). When you run the code, the Map UI will apply the 'lightsViz' visualization scheme to the 'lights' image collection. Try clicking the layers button on the top right of the map window. You should see the layer name ('Lights at night') and a check mark signifying that the layer is being shown. We made the layer opaque, so we can not see the base map underneath it, but you can use the slider to the right of the label to reduce the opacity (making the layer appear more transparent).","title":"Add map layer"},{"location":"01/rasterFoundations/#practice-problems","text":"Let's review some of the concepts we have touched on thus far. In this section, we will make small changes to the code we have written in an effort to better understand how raster methods work.","title":"Practice problems"},{"location":"01/rasterFoundations/#1-color-palette","text":"Please alter the visualization scheme by making the palette key and value pair a comment, as shown below. This will tell Earth Engine to ignore this line when you run the script. var lightsViz = { // Name of Viz object min : 0 , // Value to display with first color in palette max : 63 , // Value to display with last color in palette bands : 'stable_lights' , // Name of the band with data values // palette: lightsPalette // Refers to the palette defined previously }; After you have made this change, go ahead and run the script. What looks different about the map layer? How would you describe the palette that Earth Engine uses by default if you do not define one in the visualization scheme?","title":"1. Color palette"},{"location":"01/rasterFoundations/#2-stretch-enhancement","text":"Please alter the visualization scheme so that the min and max key and value pairs are commented, as shown below. After you have made these changes, please run the script. var lightsViz = { // Name of Viz object // min:0, // Value to display with first color in palette // max: 63, // Value to display with last color in palette bands : 'stable_lights' , // Name of the band with data values palette : lightsPalette // Refers to the palette defined previously }; How did this change the contrast of your map layer? How does this affect your ability to interpret your data? Before moving on, please be sure to undo the changes that you made to the visualization scheme to restore the original palette and stretch enhancement.","title":"2. Stretch enhancement"},{"location":"01/rasterFoundations/#3-layer-arguments","text":"Let's explore the arguments of the addLayer method. Please try to alter the arguments as described below. For each, please describe how the change affects the display of the map layer. Change the layer name to 'This is the layer name' and run the script. Change the layer visibility to 0 and run the script. Change visibility to true and run the script. Change visibility to false and run the script. Change opacity to 0 and run the script. Change opacity to true and run the script. Finally, why do you think the visibility and opacity parameters behave differently? Before moving on, please be sure to return the script to the original form described in the Add map layer section above.","title":"3. Layer arguments"}]}