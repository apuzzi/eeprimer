{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This Primer aims to help you understand foundations of geospatial analysis and visualization with Google Earth Engine. It is intended for people who are unfamiliar with geospatial or Earth Engine concepts and methods. This is a work in progress. I hope to have the first draft complete by January 2022. For questions or comments, please contact: Jeff Howarth Associate Professor Geography Department Middlebury College, Vermont, USA email: jhowarth@middlebury.edu twitter: @jeffgeographer","title":"Preface"},{"location":"00/mapFoundations/","text":"Introduction Please note: this is a rough, incomplete draft. I may develop an app for this rather than having students use the code editor. The shape of the Earth can be idealized as an ellipsoid, or something that resembles a ball that is just a little bit wider than tall. To display a map of the Earth on a computer screen, we must use a system that can 'map' locations from this three-dimensional shape to the two-dimensional surface of a computer monitor. Inevitably, this stretches space in some parts of the map and distorts some spatial properties, like distance and area. In this chapter, we will explore how the Map User Interface (UI) in Earth Engine's Code Editor uses a geographic coordinate system, a map projection, and scale to display geographic information on flat displays. We will also visualize the spatial distortions that this cartographic system creates. By the end of the chapter, you should understand how to: change the scale, extent, and basemap of the Map UI create point, line, and polygon geometries explain why the Map UI distorts distance, area, and shape of geometries Map User Interface Base layer When you start the Code Editor, the Map UI displays Google's familiar road map as the base layer . It will always be drawn first. If we add other layers to the map, the base layer will always appear on the bottom of the stack. Google's road map was designed to help people navigate transportation networks. Like any good map design, it does not clutter the map display with information that does not directly support the map's purpose. So it does not provide many details about land cover, settlement patterns, geomorphology, or other attributes of the Earth's surface that you might actually want to investigate with Earth Engine. Consequently, you may find it helpful to change the base layer to a satellite image or a shaded relief map. Use the buttons in the upper right corner of the map window to manually select a different base layer. After you have changed the layer, click run on the Code Editor to rerun your script. Note that you can change the base layer manually, but it will revert to Google's road map whenever you re-run your code. To avoid this, you can define the base layer to display on the map as part of your script. Copy and paste the snippet below into the Editor and then click Run . Map . setOptions ( 'HYBRID' ); Zoom level Zoom level defines map scale . The snippet below will print the zoom level to the Console panel whenever you run your script. print ( Map . getZoom ()); The default zoom level (4) shows a small scale map. When you increase the zoom level, you increase the map scale, which creates the illusion of bringing the map closer to you. Click on the + button in the upper left corner of map window until you can not zoom in any further. Then Run the script. You should see the number 20 in the Console window. This is the largest zoom level provided by the Map UI. Now click on the - button until you can not zoom any futher out. Then Run the script. You should see the number 0 in the Console panel. This is the smallest scale that you can view. Notice the peculiar asymmetry of the map display: it has northern and southern limits, but appears to be continuous in the eastern and western directions. As a result, the map shows places more than once. This may look strange, but as we will discuss in a minute, it helps solve an inherent problem of displaying a round object on a flat surface. Map center The map center is a point defined by a geographic coordinate . The snippet below will print the point's coordinates to the Console panel whenever you run your script. print ( Map . getCenter ()); If you are used to thinking about latitude and longitude in that order, then you should note that the order shown here is opposite of this, because it follows the \"x,y\" convention of coordinates. As a geographic coordinate, longitude is plotted along the x-axis and latitude on the y-axis, which is counter-intuitive for many people, because we tend to equate longitude with vertical lines and latitude with horizontal lines. The map's default center (-95.20, 34.80) is a point on Choctaw Nation land in southeastern Oklahoma in the USA. The longitude is a negative number, because the point lies west of the prime meridian (in Greenwich, England). The latitude is positive because the point lies north of the equator . This follows a conventional geographic coordinate system for world maps that can represent any location on Earth with a longitude between -180 and 180 and a latitude between 90 and -90. insert image Map display coordinates As noted earlier, the map displayed on your monitor does not have an eastern or western limit. In other words, it does not abruptly end at 180 degrees east and west of Greenwich. Use the pan button in the upper left of the map window to move the map center towards the east a few times (this will involve clicking and dragging towards the left). Then re-run the script. You should find that you can drag the map so that the longitude of the center point is quite a bit greater than 180 degrees. This is what generates the repeating geography we noted earlier. It may look odd, but it allows the map to display the region of Earth that spans the 180 th meridian without splitting it up on either side of the display. Often, flat world maps that are printed on paper must cut up this geography, which is why it is common to see a little piece of Russia hanging on a world map's western edge and a string of Aleutian islands creeping in from the east. Like many web maps, the Code Editor map solves this problem by extending the display's coordinate system past 180 longitude. This continuous lateral scroll also allows the map user to explore the world by panning in only one direction, similar to how a globe allows the map user to spin it one direction for any number of revolutions. On modern monitors, the lowest zoom level may appear excessive, showing the same place seven or more times. But the amount of Earth that is visible in the map window depends not only on zoom level, but also on the number of pixels that a screen can display. For example, an iPhone 5 displays only 320 x 568 pixels. At zoom level 0, this screen resolution will display a map that depicts every location on Earth twice, which means you can show any region on Earth continuously on the screen. Map extent Together, map center and zoom level define the map extent , or the region of the world displayed on the map. As you have seen, you can change these both manually with the zoom and pan buttons, Map . setCenter ( 125 , 35 , 6 ); TO BE CONTINUED...","title":"Intro to web maps"},{"location":"00/mapFoundations/#introduction","text":"Please note: this is a rough, incomplete draft. I may develop an app for this rather than having students use the code editor. The shape of the Earth can be idealized as an ellipsoid, or something that resembles a ball that is just a little bit wider than tall. To display a map of the Earth on a computer screen, we must use a system that can 'map' locations from this three-dimensional shape to the two-dimensional surface of a computer monitor. Inevitably, this stretches space in some parts of the map and distorts some spatial properties, like distance and area. In this chapter, we will explore how the Map User Interface (UI) in Earth Engine's Code Editor uses a geographic coordinate system, a map projection, and scale to display geographic information on flat displays. We will also visualize the spatial distortions that this cartographic system creates. By the end of the chapter, you should understand how to: change the scale, extent, and basemap of the Map UI create point, line, and polygon geometries explain why the Map UI distorts distance, area, and shape of geometries","title":"Introduction"},{"location":"00/mapFoundations/#map-user-interface","text":"","title":"Map User Interface"},{"location":"00/mapFoundations/#base-layer","text":"When you start the Code Editor, the Map UI displays Google's familiar road map as the base layer . It will always be drawn first. If we add other layers to the map, the base layer will always appear on the bottom of the stack. Google's road map was designed to help people navigate transportation networks. Like any good map design, it does not clutter the map display with information that does not directly support the map's purpose. So it does not provide many details about land cover, settlement patterns, geomorphology, or other attributes of the Earth's surface that you might actually want to investigate with Earth Engine. Consequently, you may find it helpful to change the base layer to a satellite image or a shaded relief map. Use the buttons in the upper right corner of the map window to manually select a different base layer. After you have changed the layer, click run on the Code Editor to rerun your script. Note that you can change the base layer manually, but it will revert to Google's road map whenever you re-run your code. To avoid this, you can define the base layer to display on the map as part of your script. Copy and paste the snippet below into the Editor and then click Run . Map . setOptions ( 'HYBRID' );","title":"Base layer"},{"location":"00/mapFoundations/#zoom-level","text":"Zoom level defines map scale . The snippet below will print the zoom level to the Console panel whenever you run your script. print ( Map . getZoom ()); The default zoom level (4) shows a small scale map. When you increase the zoom level, you increase the map scale, which creates the illusion of bringing the map closer to you. Click on the + button in the upper left corner of map window until you can not zoom in any further. Then Run the script. You should see the number 20 in the Console window. This is the largest zoom level provided by the Map UI. Now click on the - button until you can not zoom any futher out. Then Run the script. You should see the number 0 in the Console panel. This is the smallest scale that you can view. Notice the peculiar asymmetry of the map display: it has northern and southern limits, but appears to be continuous in the eastern and western directions. As a result, the map shows places more than once. This may look strange, but as we will discuss in a minute, it helps solve an inherent problem of displaying a round object on a flat surface.","title":"Zoom level"},{"location":"00/mapFoundations/#map-center","text":"The map center is a point defined by a geographic coordinate . The snippet below will print the point's coordinates to the Console panel whenever you run your script. print ( Map . getCenter ()); If you are used to thinking about latitude and longitude in that order, then you should note that the order shown here is opposite of this, because it follows the \"x,y\" convention of coordinates. As a geographic coordinate, longitude is plotted along the x-axis and latitude on the y-axis, which is counter-intuitive for many people, because we tend to equate longitude with vertical lines and latitude with horizontal lines. The map's default center (-95.20, 34.80) is a point on Choctaw Nation land in southeastern Oklahoma in the USA. The longitude is a negative number, because the point lies west of the prime meridian (in Greenwich, England). The latitude is positive because the point lies north of the equator . This follows a conventional geographic coordinate system for world maps that can represent any location on Earth with a longitude between -180 and 180 and a latitude between 90 and -90. insert image","title":"Map center"},{"location":"00/mapFoundations/#map-display-coordinates","text":"As noted earlier, the map displayed on your monitor does not have an eastern or western limit. In other words, it does not abruptly end at 180 degrees east and west of Greenwich. Use the pan button in the upper left of the map window to move the map center towards the east a few times (this will involve clicking and dragging towards the left). Then re-run the script. You should find that you can drag the map so that the longitude of the center point is quite a bit greater than 180 degrees. This is what generates the repeating geography we noted earlier. It may look odd, but it allows the map to display the region of Earth that spans the 180 th meridian without splitting it up on either side of the display. Often, flat world maps that are printed on paper must cut up this geography, which is why it is common to see a little piece of Russia hanging on a world map's western edge and a string of Aleutian islands creeping in from the east. Like many web maps, the Code Editor map solves this problem by extending the display's coordinate system past 180 longitude. This continuous lateral scroll also allows the map user to explore the world by panning in only one direction, similar to how a globe allows the map user to spin it one direction for any number of revolutions. On modern monitors, the lowest zoom level may appear excessive, showing the same place seven or more times. But the amount of Earth that is visible in the map window depends not only on zoom level, but also on the number of pixels that a screen can display. For example, an iPhone 5 displays only 320 x 568 pixels. At zoom level 0, this screen resolution will display a map that depicts every location on Earth twice, which means you can show any region on Earth continuously on the screen.","title":"Map display coordinates"},{"location":"00/mapFoundations/#map-extent","text":"Together, map center and zoom level define the map extent , or the region of the world displayed on the map. As you have seen, you can change these both manually with the zoom and pan buttons, Map . setCenter ( 125 , 35 , 6 ); TO BE CONTINUED...","title":"Map extent"},{"location":"01/rasterFoundations/","text":"Introduction This chapter introduces core concepts for representing geographic information with a raster data model. We will use Google Earth Engine to work with a dataset of nighttime lights and make the map layer shown below. By the end, you should be able to answer these questions: How does a raster data model represent attributes of spatial locations ? What is a raster's spatial resolution and extent ? What is a raster's temporal resolution and extent ? How can a raster represent multiple attributes for spatial locations at multiple times ? What is a data type versus a data value ? What is a display palette ? What is stretch enhancement and why does it help display data values with colors? Practically, you will learn how to use the Earth Engine Code Editor to: construct an image collection from an address in the Earth Engine data catalog visualize an image band with a color scheme Case study: Nighttime lights We will work with a dataset of nighttime lights available through the Earth Engine Data Catalog . Your first task is to locate the dataset in the catalog. To get started, open the Data Catalog , click on the Browse by tags tab, and then search for \"nighttime\" . You will find that the catalog contains more than one dataset with this tag. In this chapter, we will work with the Defense Meteorological Program (DMSP) Operational Line-Scan System (OLS) Time Series Version 4. There are two versions of this dataset. We will start working with the one that is not calibrated and spans the years 1992 to 2014. To check the data range, open the catalog page for a dataset and look under Data Availability . Construct image collection After you have found the DMSP OLS dataset, your next task is to create your own copy of the dataset from the data catalog and give it a name. You will need to open the Code Editor if you have not already done so. Then copy or type the following code into the Code Editor and run the script. var dataset = ee . ImageCollection ( 'NOAA/DMSP-OLS/NIGHTTIME_LIGHTS' ); print ( \"Lights at night dataset\" , dataset ); The first line creates an instance of the dataset with Earth Engine's ImageCollection method. The variable (var) provides a name for our copy of the dataset and the method's argument (in parenthesis) defines the asset ID of the dataset in the Data Catalog. The second line prints two things to the Console panel : a label and the collection's metadata (data about data). Go ahead and inspect the metadata and note the following: The image collection consists of a set of images (listed as features of the image collection). The image collection and each image has a set of properties (some of which are human readable and some of which seem intended for a computer). Each image consists of a set of bands (the names of which are a little cryptic, but you can follow the provider_url in the image collection properties to find descriptions of them). Each band has a name, a crs , a data_type , and dimensions . If this architecture and vocabulary are new to you, the next section reviews how the raster data model works as a general template for storing spatial information. Raster data model The raster data model represents spatial information as a grid of values. The position of a value in the grid represents location. Each value represents an attribute of the location. The illustration above shows two versions of a raster for a small portion of the nighttime lights dataset near Belem, Brasil. Add screenshot of region to graphic . The left-side shows how the computer encodes the data and the right-side shows a scheme that is a bit more readable. On the left, the array holds 8 bit unsigned integers. This data type uses eight binary numbers to represent integer data values between 0 and 255. The scheme on the right shows a grid with four columns and five rows. Each cell in the grid is called a pixel (short for \"picture element\"). As you can see, the raster data model stores one value for each location. INSERT A BRIDGE HERE: go back to data provider -- note that there are more than one band and more than one time. So how does that work?.. How then does the nighttime lights dataset store multiple values for each location? The solution is two-part: use more than one raster and use a hierarchy to organize them. This is where bands and image collections come in. Earth Engine's raster model insert image The figure above illustrates EE's raster system that we glimpsed earlier in the nighttime lights metadata. The image collection consists of a set of images. Each image in the image collection represents a different time observation . Each band in an image represents a different category of attributes . Now take a moment to look back at the catalog page for the dataset and acquaint yourself with the dataset descriptions. Dataset availability : temporal extent, defined by the timestamp of the first and last observation Dataset provider : data source, links to more information about the data's biography (who made the data, for what purpose, with what instruments, etc.) Earth Engine Snippet : code snippet with dataset's address to help you construct an image collection Description : a data abstract, or Google's short description of the dataset Bands : attribute categories of the dataset, or the kinds of Earth surface properties described by the dataset, along with the minimum and maximum data values for each attribute. Resolution : spatial resolution, defined as the ground distance of a pixel as measured at the equator. Terms of Use : copyright or other potential restrictions for working with the dataset. Earth Engine script : a starter script that you can copy into the Earth Engine Code Editor to load, filter, and visualize the dataset. Visualize data with color Our next task is to visualize the data as a map layer. This involves two steps: Define a color scheme for data values Apply color theme to data as a map layer The code below defines a visualization scheme that connects a set of colors to a set of data values. var palette = [ 'Black' , '#000b4a' , '#5a2c49' , '#94574e' , '#c9875e' , '#f4bf87' , 'White' ]; var viz = { min : 0 , max : 63 , bands : 'avg_vis' , palette : palette }; print ( 'palette and viz' , palette , viz ); The first variable defines a palette as a list (in brackets) of HTML colors as strings (in quotes). Our list illustrates two different ways that you can specify colors. First, you can use HTML color names , like 'Black' and 'White'. There are 140 different HTML color names that will be recognized by all modern browsers and are safe to use in Earth Engine. Alternatively, you can also define colors with hexadecimal codes , which consist of six characters following a pound sign. These allow you to create custom colors as combinations of red, green, and blue, which we will discuss in more detail in the next chapter. The second variable defines visualization parameters as an object (in curly brackets). Min and max define the data range that we want to display with colors, while palette references the list of colors we made previously. In this example, we are defining the data range based on the minimum and maximum values that populate the raster. Often, these will be documented as properties of the image collection, but not necessarily for all bands. Alternatively, you can also look in EE's Data Catalog for metadata about the collection. It is often listed under the Bands tab . Stretch enhancement Visualization parameters help resolve a common mismatch between the range of values that a raster can store (defined by the raster's data type ) and the range of values that populate the raster. Often, the range of values that populate a raster is much smaller than the range of values that the data type can represent. This affects our ability to see differences in our data with color. Stretch enhancement is a method to tune the range of display colors to the range of populated data values in order to improve visual contrast. The frequency distribution above illustrates this for our simple 20 pixel example introduced previously. It shows the number of pixels (y-axis) that populate the raster for each value provided by the data type (x-axis). The eight bit unsigned integer data type can represent all integers between 0 and 255, but our raster contains values over a much smaller range (0 - 48). Now consider that the pixel depth will also control the number of colors available to visualize the raster values. In the illustration, the palette lists six discrete colors. These colors seed a color ramp that then represents all the potential values provided by the pixel depth. The first color represents 0, the last color represents 255. The other colors are distributed evenly across the middle and transitional colors are made up to fill in the gaps. The color ramp appears continuous, but it really just represents 256 steps between black and white that pass through the other five colors at equal intervals. The raw display simply uses the color ramp to represent all the potential values in the raster as defined by the data type. The result has poor contrast, because we are only using a small part of our color ramp to display our raster values. The stretched display solves this by stretching our data range (defined by the minimum and maximum values, or 0 and 48 in this example) over the entire color ramp. This improves contrast dramatically, because we are now using our full range of color to represent our full range of populated values. Add map layer We can use this color scheme to represent raster values as a layer on the map. BELOW STILL ROUGH AND IN PIECES After we have defined how we want colors to represent data values, we can add a raster to the Map UI as a layer with this snippet: var layerParams = { eeObject : dataset , visParams : viz , name : 'Nighttime lights' , shown : 1 , opacity : 1 }; Map . addLayer ( layerParams ); This uses the Map's addLayer method after first constructing an object to hold the method's five parameters. When you run the code, the Map UI displays the lit1993 raster with our visualization parameters. When you click the layers button on the top right of the map window, you will see the layer name ('Stable lights stretched') and a check mark signifying that the layer is being shown. We made the layer opaque, so we can not see the base map underneath it. SET OF PRACTICE ACTIVITIES HERE BEFORE MOVING TO NEXT SECTION (PART 2 OF LESSON)","title":"Raster data model"},{"location":"01/rasterFoundations/#introduction","text":"This chapter introduces core concepts for representing geographic information with a raster data model. We will use Google Earth Engine to work with a dataset of nighttime lights and make the map layer shown below. By the end, you should be able to answer these questions: How does a raster data model represent attributes of spatial locations ? What is a raster's spatial resolution and extent ? What is a raster's temporal resolution and extent ? How can a raster represent multiple attributes for spatial locations at multiple times ? What is a data type versus a data value ? What is a display palette ? What is stretch enhancement and why does it help display data values with colors? Practically, you will learn how to use the Earth Engine Code Editor to: construct an image collection from an address in the Earth Engine data catalog visualize an image band with a color scheme","title":"Introduction"},{"location":"01/rasterFoundations/#case-study-nighttime-lights","text":"We will work with a dataset of nighttime lights available through the Earth Engine Data Catalog . Your first task is to locate the dataset in the catalog. To get started, open the Data Catalog , click on the Browse by tags tab, and then search for \"nighttime\" . You will find that the catalog contains more than one dataset with this tag. In this chapter, we will work with the Defense Meteorological Program (DMSP) Operational Line-Scan System (OLS) Time Series Version 4. There are two versions of this dataset. We will start working with the one that is not calibrated and spans the years 1992 to 2014. To check the data range, open the catalog page for a dataset and look under Data Availability .","title":"Case study: Nighttime lights"},{"location":"01/rasterFoundations/#construct-image-collection","text":"After you have found the DMSP OLS dataset, your next task is to create your own copy of the dataset from the data catalog and give it a name. You will need to open the Code Editor if you have not already done so. Then copy or type the following code into the Code Editor and run the script. var dataset = ee . ImageCollection ( 'NOAA/DMSP-OLS/NIGHTTIME_LIGHTS' ); print ( \"Lights at night dataset\" , dataset ); The first line creates an instance of the dataset with Earth Engine's ImageCollection method. The variable (var) provides a name for our copy of the dataset and the method's argument (in parenthesis) defines the asset ID of the dataset in the Data Catalog. The second line prints two things to the Console panel : a label and the collection's metadata (data about data). Go ahead and inspect the metadata and note the following: The image collection consists of a set of images (listed as features of the image collection). The image collection and each image has a set of properties (some of which are human readable and some of which seem intended for a computer). Each image consists of a set of bands (the names of which are a little cryptic, but you can follow the provider_url in the image collection properties to find descriptions of them). Each band has a name, a crs , a data_type , and dimensions . If this architecture and vocabulary are new to you, the next section reviews how the raster data model works as a general template for storing spatial information.","title":"Construct image collection"},{"location":"01/rasterFoundations/#raster-data-model","text":"The raster data model represents spatial information as a grid of values. The position of a value in the grid represents location. Each value represents an attribute of the location. The illustration above shows two versions of a raster for a small portion of the nighttime lights dataset near Belem, Brasil. Add screenshot of region to graphic . The left-side shows how the computer encodes the data and the right-side shows a scheme that is a bit more readable. On the left, the array holds 8 bit unsigned integers. This data type uses eight binary numbers to represent integer data values between 0 and 255. The scheme on the right shows a grid with four columns and five rows. Each cell in the grid is called a pixel (short for \"picture element\"). As you can see, the raster data model stores one value for each location. INSERT A BRIDGE HERE: go back to data provider -- note that there are more than one band and more than one time. So how does that work?.. How then does the nighttime lights dataset store multiple values for each location? The solution is two-part: use more than one raster and use a hierarchy to organize them. This is where bands and image collections come in.","title":"Raster data model"},{"location":"01/rasterFoundations/#earth-engines-raster-model","text":"insert image The figure above illustrates EE's raster system that we glimpsed earlier in the nighttime lights metadata. The image collection consists of a set of images. Each image in the image collection represents a different time observation . Each band in an image represents a different category of attributes . Now take a moment to look back at the catalog page for the dataset and acquaint yourself with the dataset descriptions. Dataset availability : temporal extent, defined by the timestamp of the first and last observation Dataset provider : data source, links to more information about the data's biography (who made the data, for what purpose, with what instruments, etc.) Earth Engine Snippet : code snippet with dataset's address to help you construct an image collection Description : a data abstract, or Google's short description of the dataset Bands : attribute categories of the dataset, or the kinds of Earth surface properties described by the dataset, along with the minimum and maximum data values for each attribute. Resolution : spatial resolution, defined as the ground distance of a pixel as measured at the equator. Terms of Use : copyright or other potential restrictions for working with the dataset. Earth Engine script : a starter script that you can copy into the Earth Engine Code Editor to load, filter, and visualize the dataset.","title":"Earth Engine's raster model"},{"location":"01/rasterFoundations/#visualize-data-with-color","text":"Our next task is to visualize the data as a map layer. This involves two steps: Define a color scheme for data values Apply color theme to data as a map layer The code below defines a visualization scheme that connects a set of colors to a set of data values. var palette = [ 'Black' , '#000b4a' , '#5a2c49' , '#94574e' , '#c9875e' , '#f4bf87' , 'White' ]; var viz = { min : 0 , max : 63 , bands : 'avg_vis' , palette : palette }; print ( 'palette and viz' , palette , viz ); The first variable defines a palette as a list (in brackets) of HTML colors as strings (in quotes). Our list illustrates two different ways that you can specify colors. First, you can use HTML color names , like 'Black' and 'White'. There are 140 different HTML color names that will be recognized by all modern browsers and are safe to use in Earth Engine. Alternatively, you can also define colors with hexadecimal codes , which consist of six characters following a pound sign. These allow you to create custom colors as combinations of red, green, and blue, which we will discuss in more detail in the next chapter. The second variable defines visualization parameters as an object (in curly brackets). Min and max define the data range that we want to display with colors, while palette references the list of colors we made previously. In this example, we are defining the data range based on the minimum and maximum values that populate the raster. Often, these will be documented as properties of the image collection, but not necessarily for all bands. Alternatively, you can also look in EE's Data Catalog for metadata about the collection. It is often listed under the Bands tab .","title":"Visualize data with color"},{"location":"01/rasterFoundations/#stretch-enhancement","text":"Visualization parameters help resolve a common mismatch between the range of values that a raster can store (defined by the raster's data type ) and the range of values that populate the raster. Often, the range of values that populate a raster is much smaller than the range of values that the data type can represent. This affects our ability to see differences in our data with color. Stretch enhancement is a method to tune the range of display colors to the range of populated data values in order to improve visual contrast. The frequency distribution above illustrates this for our simple 20 pixel example introduced previously. It shows the number of pixels (y-axis) that populate the raster for each value provided by the data type (x-axis). The eight bit unsigned integer data type can represent all integers between 0 and 255, but our raster contains values over a much smaller range (0 - 48). Now consider that the pixel depth will also control the number of colors available to visualize the raster values. In the illustration, the palette lists six discrete colors. These colors seed a color ramp that then represents all the potential values provided by the pixel depth. The first color represents 0, the last color represents 255. The other colors are distributed evenly across the middle and transitional colors are made up to fill in the gaps. The color ramp appears continuous, but it really just represents 256 steps between black and white that pass through the other five colors at equal intervals. The raw display simply uses the color ramp to represent all the potential values in the raster as defined by the data type. The result has poor contrast, because we are only using a small part of our color ramp to display our raster values. The stretched display solves this by stretching our data range (defined by the minimum and maximum values, or 0 and 48 in this example) over the entire color ramp. This improves contrast dramatically, because we are now using our full range of color to represent our full range of populated values.","title":"Stretch enhancement"},{"location":"01/rasterFoundations/#add-map-layer","text":"We can use this color scheme to represent raster values as a layer on the map. BELOW STILL ROUGH AND IN PIECES After we have defined how we want colors to represent data values, we can add a raster to the Map UI as a layer with this snippet: var layerParams = { eeObject : dataset , visParams : viz , name : 'Nighttime lights' , shown : 1 , opacity : 1 }; Map . addLayer ( layerParams ); This uses the Map's addLayer method after first constructing an object to hold the method's five parameters. When you run the code, the Map UI displays the lit1993 raster with our visualization parameters. When you click the layers button on the top right of the map window, you will see the layer name ('Stable lights stretched') and a check mark signifying that the layer is being shown. We made the layer opaque, so we can not see the base map underneath it. SET OF PRACTICE ACTIVITIES HERE BEFORE MOVING TO NEXT SECTION (PART 2 OF LESSON)","title":"Add map layer"},{"location":"02/rasterWorkflow/","text":"Introduction This chapter builds on our work in the previous chapter (Raster Foundations) . Our main goals are to explore methods of filtering, reducing, thresholding, and comparing raster datasets that are often parts of raster workflows. We will also look at a method for visualizing more than one raster at a time through the use of additive color. By the end of the chapter, you will create a new map layer (shown below) that visualizes how nighttime lights changed between 1993, 2003, and 2013. By the end of the chapter, you should understand how to: filter a collection by attribute and time reduce an image collection into an image threshold an image by criteria compare images with logical expressions visualize bands with RGB composites BELOW IS STILL VERY ROUGH AND INCOMPLETE - WILL RETURN TO IT AFTER WRAPPING UP PREVIOUS CHAPTER. Filter image collection Looking back at our result from the previous chapter, you can probably see that our image collection suffers from a bit of excess. We constructed \"lights\" from the entire dataset in the EE catalog, but we only need a subset for our analysis. So our next task is to shorten the stack of rasters. To do this, we can filter the image collection in two ways: by time by band name This snippet filters by time and prints the result to the console: var lights03 = lights . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )); print ( 'Lights 2003' , lights03 ); This calls an image collection's filter method and then uses the filter's calendarRange method, where the parameters define the range's start, end, and calendar field. In this example, we use the 'year' calendar field because each image in the nighttime lights collection represents an average for the calendar year so there is no reason to define a filter smaller than this. The second line prints a label and metadata to the Console. Inspect the metadata and note that now your image collection contains two images and both are for the year 2003. This snippet filters by band name and prints the result to the console: var lights03Select = lights03 . select ( 'stable_lights' ); print ( 'Nighttime lights 2003 Select' , lights03Select ); It calls an image collection's select method, where the parameter states the band name. Inspect the metadata and note that this image collection only contains one band. This code did the job, but it could be more concise. We could replicate all the code that we have written thus far with the following: var lights03_stable_first = ee . ImageCollection ( \"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\" ) . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )) . select ( 'stable_lights' ); print ( 'Lights 2003: concise method' , lights03_stable_first ); If you inspect the metadata, you should see this image collection is identical to the collection we made earlier. To help understand why, let's review how raster workflows work. Raster workflow elements Take a raster, do something to it, get a result. This triad is the basic element of a workflow. Input \u2192 method \u2192 output In javascript, you declare ends before means and methods are properties of the input class. The syntax is this: var output = input . method (); Most raster workflows consist of a chain or sequence of these actions. For example, our workflow thus far consists of a sequence of three. insert image When we first scripted the workflow, we declared a variable for each intermediate result and then used this variable as an input in the next step. In our more concise script, we didn't bother declaring intermediate outputs and simply wrote out the chain of action. They both work and the more verbose approach allowed us to inspect each intermediate output, which can be helpful when learning how methods work and for trouble-shooting if something goes wrong. As you become familiar with EE methods, however, you may find the concise style more efficient. ```","title":"Raster workflow"},{"location":"02/rasterWorkflow/#introduction","text":"This chapter builds on our work in the previous chapter (Raster Foundations) . Our main goals are to explore methods of filtering, reducing, thresholding, and comparing raster datasets that are often parts of raster workflows. We will also look at a method for visualizing more than one raster at a time through the use of additive color. By the end of the chapter, you will create a new map layer (shown below) that visualizes how nighttime lights changed between 1993, 2003, and 2013. By the end of the chapter, you should understand how to: filter a collection by attribute and time reduce an image collection into an image threshold an image by criteria compare images with logical expressions visualize bands with RGB composites BELOW IS STILL VERY ROUGH AND INCOMPLETE - WILL RETURN TO IT AFTER WRAPPING UP PREVIOUS CHAPTER.","title":"Introduction"},{"location":"02/rasterWorkflow/#filter-image-collection","text":"Looking back at our result from the previous chapter, you can probably see that our image collection suffers from a bit of excess. We constructed \"lights\" from the entire dataset in the EE catalog, but we only need a subset for our analysis. So our next task is to shorten the stack of rasters. To do this, we can filter the image collection in two ways: by time by band name This snippet filters by time and prints the result to the console: var lights03 = lights . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )); print ( 'Lights 2003' , lights03 ); This calls an image collection's filter method and then uses the filter's calendarRange method, where the parameters define the range's start, end, and calendar field. In this example, we use the 'year' calendar field because each image in the nighttime lights collection represents an average for the calendar year so there is no reason to define a filter smaller than this. The second line prints a label and metadata to the Console. Inspect the metadata and note that now your image collection contains two images and both are for the year 2003. This snippet filters by band name and prints the result to the console: var lights03Select = lights03 . select ( 'stable_lights' ); print ( 'Nighttime lights 2003 Select' , lights03Select ); It calls an image collection's select method, where the parameter states the band name. Inspect the metadata and note that this image collection only contains one band. This code did the job, but it could be more concise. We could replicate all the code that we have written thus far with the following: var lights03_stable_first = ee . ImageCollection ( \"NOAA/DMSP-OLS/NIGHTTIME_LIGHTS\" ) . filter ( ee . Filter . calendarRange ( 2003 , 2003 , 'year' )) . select ( 'stable_lights' ); print ( 'Lights 2003: concise method' , lights03_stable_first ); If you inspect the metadata, you should see this image collection is identical to the collection we made earlier. To help understand why, let's review how raster workflows work.","title":"Filter image collection"},{"location":"02/rasterWorkflow/#raster-workflow-elements","text":"Take a raster, do something to it, get a result. This triad is the basic element of a workflow. Input \u2192 method \u2192 output In javascript, you declare ends before means and methods are properties of the input class. The syntax is this: var output = input . method (); Most raster workflows consist of a chain or sequence of these actions. For example, our workflow thus far consists of a sequence of three. insert image When we first scripted the workflow, we declared a variable for each intermediate result and then used this variable as an input in the next step. In our more concise script, we didn't bother declaring intermediate outputs and simply wrote out the chain of action. They both work and the more verbose approach allowed us to inspect each intermediate output, which can be helpful when learning how methods work and for trouble-shooting if something goes wrong. As you become familiar with EE methods, however, you may find the concise style more efficient. ```","title":"Raster workflow elements"}]}